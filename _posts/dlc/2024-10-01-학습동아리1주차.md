---
layout: post
title: 1주차 - 분야와 배경 지식들
summary: 테스트
permalink: /:categories/:title
date: '2024-10-01 16:35:23'
category: dlc
---

* 드림핵의 [비기너즈 로드맵](https://dreamhack.io/lecture/courses/435)을 정리한 글입니다.

---

# 들어가는 말

> 기술만 익혀도 되지만 컴퓨터 그 자체의 원리와 동작을 잘 이해하고 있다면 더 잘 배울 수 있습니다.

해킹은 수단이며 목적이 아니므로 해킹 그 자체를 공부하기 위해선 명확한 동기가 있어야합니다.
위 인용문대로, 해킹을 유용하여 얻으려는 것이 물질이라면 과정의 원리원칙을 이해해야 할 필요가 없습니다.

하지만 우리가 해킹을 공부하는 목적은 해킹의 과정에서 컴퓨터과학이 응용되는 방식을 관찰하여 심도있게 이해하고 체득하기 위함입니다. 이 경우에도 마찬가지로 해킹은 수단입니다.

따라서 공부하고자 한다면, 해킹이라는 행위 자체에 너무 집착하지 않는 것이 좋겠습니다. 물론 동경하지만 목적은 아닙니다.

---

# 분야들

드림핵에선 해킹의 분야를 크게 *시스템 해킹*(System Hacking, 또는 Pwnable), *리버스 엔지니어링*(Reverse Engineering), *웹 해킹[^1]*(Web Hacking), *암호학*(Cryptography)으로 분류하고 있습니다.
(일반적으로도 크게 다르지 않게 분류하는 것 같습니다.)

비기너즈 로드맵에서는 **시스템 해킹**을 가장 먼저 소개합니다. 가장 복잡하고 많은 배경지식이 요구되는 분야이자 위의 분류 중에선 가장 넓은 개념의 분야입니다.

원칙적으로 웹 해킹, 리버스 엔지니어링 역시 시스템 해킹에 포함되지만 주로 운영체제나 프로세스를 대상으로 한 권한 에스컬레이션(Privilege Escalation)을 목적으로 합니다.
주로 C로 작성된 프로그램에 *버퍼 오버플로우*(BOF, Buffer OverFlow)[^2], *RTL*(Return To Libc)[^3], *ROP*(Return Orianted Programming)[^4] 등의 기법을 응용하여 목적을 달성합니다.
Android, macOS, iOS등의 주요 운영체제는 커널이 C로 작성된 UNIX를 기반으로 개발되었으므로 시스템 해킹을 심도있게 배운다면 유명한 운영체제들의 커널 취약점을 찾을 수도 있을 것 같습니다.

하지만 요즘엔 좀처럼 C(또한 C++)로 새로운 프로그램을 작성하지 않습니다. C로 작성된 모든 프로그램은 잠재적으로 위와 같은 무시무시한 취약점들을 내장하고 있기 때문입니다.
십 수년간 작성된 C 기반 프로그램들의 호환성을 위해 아직까지는 완전히 사용이 중단되진 않았지만, 점차 [Go나 Rust같은 비교적 안전한 언어로 대체되는 추세](https://zdnet.co.kr/view/?no=20221113014635)라고 합니다.
지금의 기법들이 근미래에 조금 더 발전하여 다른 형태로 남을지, 완전히 새로운 기법이 등장할지는 잘 모르겠습니다.

**리버스 엔지니어링**은 역공학, 공학이 하는 일을 역행하는 일입니다. 시스템 해킹을 배우기 위한 필수적인 배경지식 중 하나이며 개중에서도 배우기에 무척이나 머리가 아픈 편이라고 생각합니다.

오늘날에는 사람이 모든 프로그램을 기계어를 통해 작성하지 않습니다. 못해도 C, 나아가 Java 같은 고급 언어들을 사용하여 비교적 자연어에 가까운 형태로 프로그램을 작성합니다.
하지만 그런 추상적인 코드를 컴퓨터는 이해할 수 없습니다. 이 때문에 사람이 읽을 수 있는 코드를 읽기 매우 난해한 기계어로 변환하여 컴퓨터가 읽을 수 있도록 합니다. (컴파일)
리버스 엔지니어링은 그렇게 기계어로 변환된 프로그램(또는 이진 파일)을 사람이 읽어내서 분석하고, 이해하여 코드에 숨겨져 있는 정보를 찾아내거나 필요하다면 수정하여 프로그램이 원하는 명령을 실행할 수 있도록 패치하는 것을 목적으로 합니다.

물론 그런 복잡한 기계어를 수만 바이트씩 하나하나 읽어가며 분석하다가는 끝이 없습니다. 상용 프로그램 하나를 분석하기 위해선 일평생을 바쳐야 할지도 모릅니다.
따라서, 기계어와 일대일로 대응되는 저급 언어인 어셈블리로 변환하여 분석을 편하게 해주는 디스어셈블러(disassembler)나 변환된 어셈블리를 바탕으로 의사코드(pseudo code)를 생성해주는 디컴파일러(decompiler) 등을 이용하여 프로그램을 분석합니다.

드림핵 비기너즈 로드맵에서는 리버스 엔지니어링 강의 수강에 필요한 사전지식을 아래의 코드를 읽고 질문에 답할 수 있는지 여부로 진단합니다.
```c
#include <stdio.h>

int enc[17] = {75, 104, 111, 111, 114, 35, 71, 117, 104, 100, 112, 107, 100, 102, 110, 36, 3};

int main(){

    int key = 0;
    int dec[17];

    for(int i=0; i<17; i++){
        printf("%c", enc[i]);
    }

    printf("\nYour input: ");
    scanf("%d", &key);

    for(int i=0; i<17; i++){
        dec[i] = enc[i] - key;
        printf("%c", dec[i]);
    }
    printf("\n");

    return 0;
}

// 위 코드를 컴파일한 어셈블리 코드

Dump of assembler code for function main:
   0x00005555555551a9 <+0>:     endbr64 
   0x00005555555551ad <+4>:     push   rbp
   0x00005555555551ae <+5>:     mov    rbp,rsp
   0x00005555555551b1 <+8>:     sub    rsp,0x60
   0x00005555555551b5 <+12>:    mov    rax,QWORD PTR fs:0x28
   0x00005555555551be <+21>:    mov    QWORD PTR [rbp-0x8],rax
   0x00005555555551c2 <+25>:    xor    eax,eax
   0x00005555555551c4 <+27>:    mov    DWORD PTR [rbp-0x5c],0x0
   0x00005555555551cb <+34>:    mov    DWORD PTR [rbp-0x58],0x0
   0x00005555555551d2 <+41>:    jmp    0x5555555551f6 <main+77>
   0x00005555555551d4 <+43>:    mov    eax,DWORD PTR [rbp-0x58]
   0x00005555555551d7 <+46>:    cdqe   
   0x00005555555551d9 <+48>:    lea    rdx,[rax*4+0x0]
   0x00005555555551e1 <+56>:    lea    rax,[rip+0x2e38]        # 0x555555558020 <enc>
   0x00005555555551e8 <+63>:    mov    eax,DWORD PTR [rdx+rax*1]
   0x00005555555551eb <+66>:    mov    edi,eax
   0x00005555555551ed <+68>:    call   0x555555555080 <putchar@plt>
   0x00005555555551f2 <+73>:    add    DWORD PTR [rbp-0x58],0x1
   0x00005555555551f6 <+77>:    cmp    DWORD PTR [rbp-0x58],0x10
   0x00005555555551fa <+81>:    jle    0x5555555551d4 <main+43>
   0x00005555555551fc <+83>:    lea    rax,[rip+0xe01]        # 0x555555556004
   0x0000555555555203 <+90>:    mov    rdi,rax
   0x0000555555555206 <+93>:    mov    eax,0x0
   0x000055555555520b <+98>:    call   0x5555555550a0 <printf@plt>
   0x0000555555555210 <+103>:   lea    rax,[rbp-0x5c]
   0x0000555555555214 <+107>:   mov    rsi,rax
   0x0000555555555217 <+110>:   lea    rax,[rip+0xdf4]        # 0x555555556012
   0x000055555555521e <+117>:   mov    rdi,rax
   0x0000555555555221 <+120>:   mov    eax,0x0
   0x0000555555555226 <+125>:   call   0x5555555550b0 <__isoc99_scanf@plt>
   0x000055555555522b <+130>:   mov    DWORD PTR [rbp-0x54],0x0
   0x0000555555555232 <+137>:   jmp    0x55555555526f <main+198>
   0x0000555555555234 <+139>:   mov    eax,DWORD PTR [rbp-0x54]
   0x0000555555555237 <+142>:   cdqe   
   0x0000555555555239 <+144>:   lea    rdx,[rax*4+0x0]
   0x0000555555555241 <+152>:   lea    rax,[rip+0x2dd8]        # 0x555555558020 <enc>
   0x0000555555555248 <+159>:   mov    eax,DWORD PTR [rdx+rax*1]
   0x000055555555524b <+162>:   mov    ecx,DWORD PTR [rbp-0x5c]
   0x000055555555524e <+165>:   sub    eax,ecx
   0x0000555555555250 <+167>:   mov    edx,eax
   0x0000555555555252 <+169>:   mov    eax,DWORD PTR [rbp-0x54]
   0x0000555555555255 <+172>:   cdqe   
   0x0000555555555257 <+174>:   mov    DWORD PTR [rbp+rax*4-0x50],edx
   0x000055555555525b <+178>:   mov    eax,DWORD PTR [rbp-0x54]
   0x000055555555525e <+181>:   cdqe   
   0x0000555555555260 <+183>:   mov    eax,DWORD PTR [rbp+rax*4-0x50]
   0x0000555555555264 <+187>:   mov    edi,eax
   0x0000555555555266 <+189>:   call   0x555555555080 <putchar@plt>
   0x000055555555526b <+194>:   add    DWORD PTR [rbp-0x54],0x1
   0x000055555555526f <+198>:   cmp    DWORD PTR [rbp-0x54],0x10
   0x0000555555555273 <+202>:   jle    0x555555555234 <main+139>
   0x0000555555555275 <+204>:   mov    edi,0xa
   0x000055555555527a <+209>:   call   0x555555555080 <putchar@plt>
   0x000055555555527f <+214>:   mov    eax,0x0
   0x0000555555555284 <+219>:   mov    rdx,QWORD PTR [rbp-0x8]
   0x0000555555555288 <+223>:   sub    rdx,QWORD PTR fs:0x28
   0x0000555555555291 <+232>:   je     0x555555555298 <main+239>
   0x0000555555555293 <+234>:   call   0x555555555090 <__stack_chk_fail@plt>
   0x0000555555555298 <+239>:   leave  
   0x0000555555555299 <+240>:   ret    
End of assembler dump.
```

1. `프로그램이 실행 되었을 때 프로그램이 어떠한 동작을 하는지 설명할 수 있다.`
2. `c 코드의 enc[17] 와 key 가 메모리에 배치될 때 각각 어떠한 메모리 세그먼트에 위치할지 대략적으로 설명할 수 있다.`
3. `메모리와 레지스터의 차이를 설명할 수 있다.`
4. `명령어 집합 구조(Instruction Set Architecture, ISA)가 무엇인지 설명할 수 있다.`
5. `c 코드가 어떠한 과정을 거쳐 컴파일 되는지, 그리고 컴파일 과정에서 코드가 어떻게 바뀌는지 설명할 수 있다.`
6. `c, 어셈블리, 바이너리 코드 각각의 특징과 그 차이점에 대해 설명할 수 있다.`
7. `어셈블리 코드를 보고 main 함수의 stack frame 구조를 파악할 수 있다.`
8. `어셈블리 코드를 보고 메모리와 레지스터를 구분할 수 있다.`
9. `어셈블리를 보고 동일한 기능을 하는 C 코드를 작성할 수 있다.`
10. `c 코드에서 int형 배열이 문자로 출력될 수 있는 이유를 설명할 수 있다.`
11. `“Hello dreamhack!” 을 출력하도록 하는 key 값을 구할 수 있다.`

제가 답할 수 있는건 1, 2, 3, 5, 8, 10, 11번 정도입니다.

그 다음으로 소개하는건 **웹 해킹** 입니다. 미디어의 영향인지, 보통 '해킹'이라고 한다면 웹 해킹을 가장 먼저 떠올리게 되는 것 같습니다.

웹 해킹은 웹 상에서 본래의 의도와 다른 동작을 일으키거나 데이터를 도용, 변조, 시스템을 손상시키는 등의 악의적인 행위를 수행하는 것을 말합니다.
Web 2.0 이후의 웹들은 제공하는 서비스가 매우 다양해지고 복잡한 기능을 구현하면서 의도치 않은 동작을 일으킬 수 있는 웹 해킹의 위협도 증가했습니다.
드림핵에서는 웹 해킹 강의를 총 3개로 분류합니다.

1. 기초적인 네트워크 지식들과 웹 브라우저의 원리 잘 알려진 웹 해킹 기법들의 대략적인 원리를 배울 수 있는 Web Hacking Fundamental 카테고리
2. 1번 로드맵의 배경 지식을 바탕으로 웹 서버 개발 시 사용되는 다양한 데이터베이스들에 대해 알아보고 그에 대해 수행할 수 있는 SQL Injection, 서버의 운영체제 단에서 악의적인 임의 명령을 실행시킬 수 있는 Command Injection 기법에 대해 배울 수 있는 Web Hacking Advanced - Server Side 카테고리
3. 1번 로드맵의 배경 지식을 바탕으로 클라이언트 사이드(아마도 방문자)에게 일어날 수 있는 공격 기법과 필터링을 통한 보안, 그를 우회하는 방법에 대해 알아보는 Web Hacking Advanced - Client Side 카테고리

리버스 엔지니어링, 시스템 해킹과 마찬가지로 웹 해킹 역시도 웹 개발 경험이 있다면 훨씬 더 수월하게 배울 수 있습니다. 자주 사용되는 프레임워크와 기술 스택들을 사용해본 경험이 있다면 더욱 좋습니다.
드림핵의 웹 해킹 강의는 적어도 Flask, NodeJS, 그리고 Spring 중 한 가지 프레임워크로 작성된 웹 소스를 읽고 이해할 수 있는 수준임을 전제로 합니다. 

마지막으로 **암호학** 입니다. 시스템 해킹, 리버스 엔지니어링 CTF 문제 풀이에서도 얕게나마 활용됩니다.

학습동아리 학습과정엔 포함되어있진 않으나 드림핵 로드맵에선 암호학이 무엇이며 어떤 내용을 배우는지 소개하고, Cryptography 로드맵 수강에 필요한 지식을 간단하게 설명합니다.
암호학은 개인정보 관리, 전자상거래, 클라우드 서비스 등 보안을 유지해야 하는 다양한 영역에서 사용됩니다. 사실은 거의 대부분의 '해킹'에 관여합니다. 해킹을 까다롭게 하기 위한 수단으로써도 자주 이용되기 때문입니다.

보통은 비트 연산(특히 XOR)과 모듈러 연산을 통해 보호하려는 정보를 암호화합니다.

---

<!-- 각주 -->
[^1]: <span style="color:gray; font-size:95%; ">또는 더 넓은 개념인 *네트워크 해킹*(Network Hacking)에 포함해서 분류합니다.</span>
[^2]: <span style="color:gray; font-size:95%">스택의 낮은 주소부터 높은 주소로 쓰여지는 성질(LIFO)을 이용하여 프로세스가 임의의 명령을 실행시키도록 하는 공격 기법</span>
[^3]: <span style="color:gray; font-size:95%">프로세스와 데이터 저장 메모리 영역을 따로 분리하는 보호기술(NX-Bit)을 우회하기 위해 기본적으로 임포트 되어있는 libc(C 표준라이브러리, C++의 STL과 개념적으로 비슷한 것 같습니다.)의 함수들을 호출하여 임의의 명령을 실행하는 공격 기법</span>
[^4]: <span style="color:gray; font-size:95%">RTL 기법을 기반으로하여 적절한 가젯(Gadget, 코드 조각)들을 조합한 뒤 메모리 보호 기법(아마도 BOF를 방지하기 위한)을 우회하여 임의의 명령을 실행하는 공격 기법</span>