---
layout: post
title: 5주차 - 시스템 해킹 기초(1)
summary: 테스트
permalink: /:categories/:title
date: '2024-10-29 17:12:48'
category: dlc
---

* 드림핵의 [시스템 해킹 로드맵](https://dreamhack.io/lecture/roadmaps/2)을 정리한 글입니다.

---

# 컴퓨터 구조

> 컴퓨터는 각자 다른 기능을 수행하는 여러 부품들의 도움으로 작동합니다. CPU는 컴퓨터의 작동에 핵심이 되는 연산을 처리하고, 저장장치는 데이터를 저장합니다. 이 외에도 GPU는 그래픽 데이터를, 랜카드는 네트워크 통신을, 사운드 카드는 소리 데이터를 처리하는 것에 특화되어 있습니다. 각 부품들은 특징이 뚜렷하여 컴퓨터에서 고유의 기능을 수행합니다. <br><br>이처럼 서로 다른 부품들이 모여서 ‘컴퓨터’라는 하나의 기계로서 작동할 수 있는 것은 컴퓨터에 대한 기본 설계가 존재하기 때문입니다. 이 설계에 맞춰서 여러 하드웨어가 개발되고, 이들을 조립해서 컴퓨터가 완성됩니다. 컴퓨터 과학에서는 이러한 설계를 ‘컴퓨터 구조(Computer Architecture)’라고 부릅니다.[^1]

컴퓨터의 구조와 작동 방식을 이해하는 것은 시스템 해킹에 있어 매우 중요한 일입니다. 시스템 해킹은 궁극적으로 프로세스에 구현되지 않은 동작을 실행하는 행위와 마찬가지이므로, 프로세스의 취약점을 찾아 보다 낮은 수준에서 프로세스를 재구성해야합니다.

이를 위해선 반드시 컴퓨터가 어떻게 이루어져있고, 어떻게 작동하는지에 대해 어느정도 심도있게 이해하고 있어야합니다. 그렇지 않고서는 한 발짝도 나아갈 수 없습니다. 아래는 컴퓨터 각각의 구성요소와 상호작용의 대략적인 모식도입니다.
![](/assets/img/PWN_ComArc.PNG)
*출처 : 한빛미디어, 혼공 "[컴퓨터 구조] 컴퓨터의 4가지 핵심 부품: CPU, 메모리, 보조기억장치, 입출력장치"[^2]*

컴퓨터 구조에 자세히 이해해보고 싶다면, 관련된 좋은 서적이 참 많이 있습니다. 개인적으로는 위 참고 자료의 출처인 *혼자 공부하는 컴퓨터 구조+운영체제*(2022, 한빛미디어, 강민철 저)를 읽어보시길 추천드립니다. 비전공자들도 이해하기 쉽도록 짜임 좋게 잘 구성되어있는 책입니다. 

사실 컴퓨터 구조에 대해 자세히 설명하자면 끝이 없습니다. 이 글을 작성하는 년도 기준으로, 컴퓨터는 만들어진지 채 1세기도 되지 않은 기계임에도 우리 주변에서 볼 수 있는 그 어떤 것들보다도 복잡하고 정교하게 설계되었습니다. 그러니, 제 생각에 시스템 해킹 및 리버스 엔지니어링에 요구되는 필수 배경 지식들만을 키워드 형태로 나열해보겠습니다.

1. 폰 노이만 구조
2. x86, x86-64
3. 레지스터, 캐시
4. 함수 호출 규약
5. 자료 구조

안타깝게도, 이 게시물에선 위에 나열한 모든 내용에 대해 상세히 설명하진 못했습니다.

---

# 폰 노이만 구조(von Neumann architecture)

![](/assets/img/PWN_Von_Neumann_Arc.PNG)
*Wikipedia, von Neumann architecture: A von neumann architecture scheme[^3]*

위에서 보았던 모식도의 요소들을 좀 더 거시적인 관점에서 본다면, 이런 식으로 더 간소화될 수 있습니다.
이것이 바로 거의 모든 현대 컴퓨터가 채택하고 있는 가장 근원적인 골조, 폰 노이만 구조입니다.

제어 장치, 연산 장치, 기억 장치, 입력 장치, 출력 장치가 최소한의 구성요소입니다. 각각 CPU, RAM, 키보드와 마우스, 모니터라고 생각하면 더욱 직관적으로 이해할 수 있을 것 같습니다.

초기 컴퓨터 과학자였던 폰 노이만은 컴퓨터에는 연산, 제어, 저장의 세 가지 핵심 기능이 필요하다고 생각했습니다. 연산과 제어를 위해 *CPU*(Central Processing Unit, CPU)를, 프로그램의 저장을 위해 *기억장치*(memory)를 사용합니다. 장치간 데이터나 제어 신호를 교환하기 위해서 *버스*(bus)라는 전자 통로를 사용합니다.

기억장치에는 여러 종류가 있습니다. 명령을 저장하는 레지스터, 프로세스를 저장하는 주기억장치, 프로그램을 저장하는 부기억장치를 비롯해, 더 지어내자면 마음가는 만큼 많이 지어낼 수 있습니다. 각각의 저장장치는 속도와 용량, 비용에 따라 용도와 이름이 달라집니다. (속도는 CPU에 포함된 레지스터, 캐시 메모리, 주저장장치, 부저장장치 순으로 빠릅니다.)

부저장장치(SSD, HDD 따위)에 저장된 프로그램을 *주저장장치*(RAM)에 로드해서, 명령어 단위로 프로그램을 잘게 쪼개 레지스터에 넣습니다. 인출된 명령어를 ALU가 순차적으로 처리합니다.

---

# 자주 사용되는 레지스터와 플래그들

* x86-64 아키텍처의 레지스터

|이름|주용도|
|-|-|
|rax (accumulator register)|함수의 반환값|
|rbx (base register)|x64에서는 주된 용도 없음|
|rcx (counter register)|반복문의 반복 횟수, 각종 연산의 시행 횟수|
|rdx (data register)|x64에서는 주된 용도 없음|
|rsi (source index)|데이터를 옮길 때 원본을 가리키는 포인터|
|rdi (destination index)|데이터를 옮길 때 목적지를 가리키는 포인터|
|rsp (stack pointer)|사용중인 스택의 위치를 가리키는 포인터|
|rbp (stack base pointer)|스택의 바닥을 가리키는 포인터|

'용도'가 아닌 '주용도'라고 기술한 이유는 각 레지스터가 어떤 역할만을 하도록 구조적으로 강제되어있지 않기 때문입니다. rax를 rcx처럼, rsi를 rdi처럼 사용해도 아무런 문제가 없습니다. 변수의 쓰임과 그다지 다를 바가 없다는 말입니다.

x86-64 아키텍처는 IA-32의 확장 아키텍처이며 하위 호환성을 가지고 있습니다. IA-32에서의 각 레지스터 명칭은 레지스터 명칭 맨 앞의 접두사 r을 e로 바꾼 형태입니다. (eax, ebx, ecx, edc, esi, edi...)
또, IA-32는 과거 16비트 아키텍처인 IA-16의 확장 아키텍처이고 하위 호환성을 가지고 있습니다.
(마트료시카같네요.)

위는 범용 레지스터의 종류이며 이외에도 메모리를 보호하기 위한 세그먼트 레지스터, 명령어 포인터 레지스터(instruction pointer)가 존재합니다.

- 플래그

|플래그|의미|
|-|-|
|CF(Carry Flag)|부호 없는 수의 연산 결과가 비트의 범위를 넘을 경우 설정 됩니다.|
|ZF(Zero Flag)|연산의 결과가 0일 경우 설정 됩니다.|
|SF(Sign Flag)|연산의 결과가 음수일 경우 설정 됩니다.|
|OF(Overflow Flag)|부호 있는 수의 연산 결과가 비트 범위를 넘을 경우 설정 됩니다.|

플래그 레지스터는 프로세서의 현재 상태를 저장하고 있는 레지스터입니다. x64 아키텍처에서는 RFLAGS라고 불리는 64비트 크기의 플래그 레지스터가 존재하며, 과거 16비트 플래그가 확장된 것입니다. 깃발을 올리고, 내리는 행위로 신호를 전달하듯, 플래그 레지스터는 자신을 구성하는 여러 비트들로 CPU의 현재 상태를 표현합니다.

RFLAGS는 64비트이므로 최대 64개의 플래그를 사용할 수 있지만, 실제로는 20여개의 비트만을 사용합니다.

---

# 리눅스의 메모리 구조

![](/assets/img/PWN_Linux_mem.png)
*드림핵 시스템 해킹 로드맵, Background: Linux Memory Layout[^4]*

리눅스에서는 프로세스의 메모리를 크게 5가지의 세그먼트(Segment) 로 구분합니다. 세그먼트란 적재된 데이터를 용도별로 나눠 저장하는 구획입니다.
크게 *코드 세그먼트*, *데이터 세그먼트*, *BSS 세그먼트*, *힙 세그먼트*, 그리고 *스택 세그먼트*로 구분합니다.

이렇게 메모리를 여러 세그먼트로 나눴을때의 장점은, 각 용도에 맞게 적절한 권한을 부여하여 메모리 오염을 방지할 수 있다는 점이 있습니다. 실행 중인 프로세스는 아래와 같은 5개의 영역으로 쪼개져 읽고, 쓰고, 실행된다고 합니다.

- **코드 세그먼트**

코드 세그먼트는 실행 가능한 기계 코드(이진 코드)가 위치하는 영역으로, 텍스트 세그먼트라고도 불립니다.
프로그램이 동작하려면 코드를 실행할 수 있어야 하므로, 이 세그먼트에는 읽기 권한과 실행 권한이 부여됩니다.

- **데이터 세그먼트**

컴파일 시점에 값이 정해진 전역 변수 및 전역 상수들이 위치하는 영역입니다.
데이터 세그먼트는 값이 변할 수 있는 데이터가 위치한 *data 세그먼트*, 변하면 안되는 데이터(예를 들면 상수라던가)가 위치한 *rodata(read-only data) 세그먼트*라고 부릅니다.
CPU가 이 세그먼트의 데이터를 읽을 수 있어야 하므로, 이 세그먼트에는 기본적으로 읽기 권한이 부여됩니다.

- **BSS 세그먼트**(BSS Segment, Block Started By Symbol Segment)

컴파일 시점에 값이 정해지지 않은 전역 변수가 위치하는 영역입니다.
여기에는 개발자가 선언만 하고 초기화하지 않은 전역변수 등이 포함됩니다. 이 세그먼트의 메모리 영역은 프로그램이 시작될 때, 모두 0으로 값이 초기화됩니다.
이 세그먼트에는 읽기 권한 및 쓰기 권한이 부여됩니다.

- **스택 세그먼트**

프로세스의 스택이 위치하는 영역입니다.
함수의 인자나 지역 변수와 같은 임수 변수들이 실행중에 여기에 저장됩니다.
스택 세그먼트는 *스택 프레임(Stack Frame)* 이라는 단위로 사용됩니다. 스택 프레임은 함수가 호출될 때 생성되고, 반환될 때 해제됩니다. 스택 프레임의 크기는 동적이며, 필요에 따라 커지고 작아집니다.
CPU가 자유롭게 값을 읽고 쓸 수 있어야 하므로, 이 세그먼트에는 읽기와 쓰기 권한이 부여됩니다.

- **힙 세그먼트**

힙 데이터가 위치하는 세그먼트입니다. 스택과 마찬가지로 실행중에 동적으로 활당될 수 있으며, 리눅스에서는 스택 세그먼트와 반대 방향으로 자랍니다. (위 이미지 참고)
C에서 malloc(), calloc() 등을 호출해서 할당받는 메모리가 이 세그먼트에 위치하게 되며, 일반적으로 읽기와 쓰기 권한이 부여됩니다.

---

# 셸코드(Shellcode)

셸코드(Shellcode)는 익스플로잇을 위해 제작된 어셈블리 코드 조각을 일컫습니다. 일반적으로 셸을 획득하기 위한 목적으로 셸코드를 사용해서, 특별히 “셸”이 접두사로 붙었다고 합니다.

공격자가 rip(명령어 포인터 레지스터)를 자신이 작성한 셸코드를 가리키도록하면 공격자가 원하는 코드를 실행되게 할 수 있습니다. 단, 이러한 코드는 기계어(이진 코드)로 작성돼야합니다. 어셈블리어로 함수를 작성해야한다는 의미입니다.

[여기에서](https://shell-storm.org/shellcode/index.html) 여러 시스템에 맞춰 작성된 셸코드들을 볼 수 있습니다.
직접 작성해보려고 결여된 배경 지식이 너무나도 방대했습니다. 시스템 해커분들께 경의를 표합니다.

---

[^1]: [드림핵 시스템 해킹 로드맵, Background: Computer Architecture](https://learn.dreamhack.io/43#1)
[^2]: [https://hongong.hanbit.co.kr/컴퓨터의-4가지-핵심-부품cpu-메모리-보조기억장치/](https://hongong.hanbit.co.kr/%EC%BB%B4%ED%93%A8%ED%84%B0%EC%9D%98-4%EA%B0%80%EC%A7%80-%ED%95%B5%EC%8B%AC-%EB%B6%80%ED%92%88cpu-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%B3%B4%EC%A1%B0%EA%B8%B0%EC%96%B5%EC%9E%A5/)
[^3]: [Wikipedia, von Neumann architecture](https://en.wikipedia.org/wiki/Von_Neumann_architecture)
[^4]: [드림핵 시스템 해킹 로드맵, Background: Linux Memory Layout](https://learn.dreamhack.io/52#2)