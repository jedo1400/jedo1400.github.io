---
layout: post
title: 6주차 - 시스템 해킹 기초(2)
summary: 테스트
permalink: /:categories/:title
date: '2024-11-05 09:44:58'
category: dlc
---

* 드림핵의 [시스템 해킹 로드맵](https://dreamhack.io/lecture/roadmaps/2)을 정리한 글입니다.

---

# 스택 버퍼 오버플로우(Stack Buffer OverFlow, BOF)

스택 버퍼 오버플로우는 스택의 버퍼에서 발생하는 오버플로우를 뜻합니다. 대부분의 버퍼 오버플로우는 스택 버퍼 오버플로우를 의미합니다. 
버퍼(Buffer)는 일상에서 ‘완충 장치'라는 뜻으로 사용되며, 컴퓨터 과학에서는 ‘데이터가 목적지로 이동되기 전에 보관되는 임시 저장소’의 의미로 쓰입니다.

데이터의 처리속도가 다른 두 장치가 있을 때, 이 둘 사이에 오가는 데이터를 임시로 저장해 두는 것은 일종의 완충 작용을 합니다. 만약 버퍼가 없다면, 병목 현상으로 인해 작업을 처리하는 속도가 아주아주 느려지거나, 너무 빠른 장치가 너무 느린 장치의 입력을 무시하고 

> **스풀링과 버퍼링의 차이?**
임시 데이터를 저장하는 공간으로 스풀링은 주기억장치(RAM)를, 버퍼는 부기억장치(SSD, HDD)를 사용합니다.

버퍼 오버플로우는 말 그대로 버퍼가 흘러 넘치는 것을 의미합니다.
버퍼는 제각기 크기를 가지고 있는데, int로 선언한 지역 변수는 4바이트의 크기를 갖고, 10개의 원소를 갖는 char 배열은 10바이트의 크기를 갖습니다. 만약 10바이트 크기의 버퍼에 20바이트 크기의 데이터가 들어가려 하면 오버플로우가 발생합니다. 특히 문자열을 입력받는 경우에 많이 발생합니다.

일반적으로 버퍼는 스택 세그먼트 상에서 공간이 연속적으로 할당되어있습니다. 따라서, 어떤 버퍼에서 오버플로우가 발생하면, 뒤에 있는 버퍼들의 값이 조작될 위험이 있습니다. 이러한 취약점을 통해 BOF로 반환 주소(RIP)를 임의의 주소로 변조하여 원하는 동작을 실행시킬 수 있습니다. 그외에도 변수의 값을 임의로 변조하거나 하드코딩된 데이터를 엿 볼 수도 있습니다.

---

# BOF에 취약한 C 함수들

1. ```c
    strcpy(char *dest, const char *src);
```
2. ```c
    strcat(char *dest, const char *src);
```
3. ```c
    getwd(char *buf);
```
4. ```c
    gets(char *s);
```
5. ```c
    fscanf(FILE *stream, const char *format, …);
```
6. ```c
    scanf(const char *format, …);
```
7. ```c
    realpath(char *path, char resolved_path[ ]);
```
8. ```c
    sprintf(char *str, const char *format);
```

vs에만 있는 scanf_s를 사용한다면 문자열을 입력받을 때 버퍼의 최대 길이를 지정하여 BOF를 방지할 수 있습니다.
STL의 cin 역시도 취약하니 프로그램의 용도에 따라서 사용에 유의하도록 합시다.
