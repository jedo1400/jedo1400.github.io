---
layout: post
title: 7주차 - 리버스 엔지니어링 기초(1)
summary: 테스트
permalink: /:categories/:title
date: '2024-11-12 20:12:40'
category: dlc
---

* 드림핵의 [리버스 엔지니어링 로드맵](https://dreamhack.io/lecture/roadmaps/4)을 정리한 글입니다.

---

# 바이너리

컴퓨터에게 명령하기 위해선, 컴퓨터가 이해할 수 언어를 사용해서 명령해야합니다.
그런데, 잘 생각해보면 어이가 없습니다. 컴퓨터가 대체 무슨 언어를 이해할 수 있다는걸까요?

Intel, AMD와 같은 주요 CPU 제조사들은, *ISA*(Instruction Set Architecture)라는 컴퓨터가 이해할 수 있는 명령의 집합을 만들었습니다. 회로 수준에서 구현된 기능들을 실행할 수 있도록 하는 명령어인 것입니다.
ISA에 존재하는 각각의 명령들을 *옵코드*(Opcode)라고 하고 그 명령과 함께 주어지는 인수들을 *오퍼랜드*(Operand)라고 부릅니다.

이 옵코드들은 문서 상으로는 영문으로 된 이름이 존재합니다. *MOV*, *ADD*, *JMP*와 같은 식으로 말입니다. 하지만, 막상 컴파일 된 프로그램을 열어보면 각종 알아볼 수 없는 형태의 이상한 문자들만이 적혀있는 것을 알 수 있습니다. 컴파일 과정에서 위 명령어들은 자연어 형식이 아닌 각 명령어에 임의로 할당된 번호로 인코딩되기 때문입니다.

컴퓨터가 이해할 수 있는 것은 결국 언어가 아니라 상태, 정확히는 0과 1입니다.

---

# 프로그램

우리는 필요에 따라 여러 상용 프로그램들을 온라인에서 다운로드하여 사용합니다. 이러한 '프로그램'이라는 개념은 굉장히 기발합니다. 우리가 일상에서 여러 명에게 공유해야하거나 지시할 사항이 있다면, 그것을 자세히 문서화하여 상대방이 읽도록 하는 편이 효율적일 것입니다. 프로그램은 이러한 효율적인 지시 방법인 '문서화'에서 착안한 개념입니다.

프로그램 형태로 컴퓨터에게 간편하게 원하는 명령을 내릴 수 있는 컴퓨터를 Stored-Program Computer라고 합니다. 대부분의 근현대 컴퓨터는 이러한 형태를 채택했습니다.

---

# 컴파일

명령의 모음인 프로그램은 명령의 순서와 명령에 사용해야 할 상수와 변수, 입출력 함수를 포함해야합니다. 앞서 드림핵에서 로컬환경에서 문제를 간편하게 실행하기 위해 도커를 사용하는 것과 같이, 사용자가 프로그램을 사용하기 위해 들여야하는 노력을 최대한 줄여야합니다. 이를 위해 필요한 과정이 **컴파일**입니다.

컴파일 과정은 대체로 매크로(#define) 치환 과정과 주석 제거, 파일 병합 등의 *전처리*(Preprocess), 고급 언어의 코드를 저급 언어로 변환하는 *컴파일*(Compile), 운영체제에 따라 이진 코드 파일을 생성하는 *어셈블*(Assemble), 사용되는 라이브러리들을 연결하는 *링크*(Link) 과정을 포함합니다. 컴파일 과정을 자동화하는 *컴파일러*는 투입된 원시 코드를 통해 실행 가능한 형태의 이진 코드 파일을 생성합니다. 이때 생성되는 파일이 바로 PE, ELF와 같은 형태의 프로그램입니다.

Python, Javascript와 같은 인터프리터 언어의 경우 컴파일 과정을 일부 생략하고 전처리, 어셈블, 링크 정도의 과정만으로 실행될 수 있습니다.

---

# 정적 분석

그럼 우리는 기계만 알아들을 수 있는 파일을 분석하기 위해 어떤 방식으로 접근해야할까요?
일단, 실행 가능한 프로그램의 이진 코드를 *디스어셈블*(Disassemble)하는 과정을 거쳐 어셈블리 코드로 변환합니다. 그 후 프로그램이 어떤 운영체제를 대상으로 빌드되었는지(어셈블 되었는지), 무슨 언어로 작성되었는지 파악합니다. ELF와 PE 파일로 컴파일되었을 경우엔 프로그램은 이러한 아티팩트를 실행을 위해 어쩔 수 없이 포함하게됩니다.

하지만, 디스어셈블 된 코드가 사람이 읽을 수 있는 형태이지만서도 분석하기 정말 쉽지 않습니다. 우리는 단어를 기반으로 한 문장을 구사하고, 이해합니다. 하지만 컴퓨터는 그렇지 않습니다. 문장의 각 단어를 자소로 쪼개는 것도 모자라, 그를 발음 기호로 독음해줘야만 이해할 수 있는 이상한 놈입니다.
심지어 같은 기능이라도, 구현된 언어와 알고리즘에 따라 어셈블리 코드의 형태가 완전히 다릅니다. 많은 경험으로 숙련된 리버서가 아니라면, CTF에 출제되는 프로그램이 아닌 상용 프로그램을 어셈블리 코드만 보고 분석하는 것은 불가능에 가깝습니다.

고맙게도 최근에 들어서는 *디컴파일러*(Decompiler)라는 것이 등장했습니다. 디컴파일은 문자 그대로 컴파일 된 상태를 되돌려준다는 의미입니다. 
하지만 어떻게요? 세상에는 너무나 많은 언어가 존재합니다. 자주 쓰이는 컴파일 언어만을 추리더라도 그에 모두 대응하는 디컴파일러를 개발하기엔 너무 난이도가 높습니다. 기본적으로 제공되는 함수 역시도 너무나 많고 구현이 복잡합니다.

그래서, 현존하는 대부분의 디컴파일러는 프로그램을 완전한 형태로 디컴파일하지 못합니다. C 스타일의 의사코드로 어셈블리 코드를 해석하는 정도입니다. 물론 이정도만 하더라도 감지덕지입니다. 프로그램이 작동하는 구조를 편하게 분석하기에는 충분합니다.

위에서 설명한 여러 형태의 분석은 *정적 분석*(Static Analysis)으로 분류되는 분석 기법입니다. 분석 환경의 제약에서도 비교적 자유롭고 바이러스 등의 악성 프로그램을 분석하기 위해서 별도의 샌드박스 구축이 필요없어 편리합니다. 하지만, 코드가 난독화 되어있거나 실행 흐름이 복잡한 경우 분석에 많은 시간이 소요될 수 있습니다.

---

# 동적 분석

그에 반해 *동적 분석*(Dynamic Analysis)은 프로그램을 실행시키지 않은 상태로 분석하는 정적 분석과 달리 프로그램을 실행시키면서 분석하는 방법입니다.

동적분석을 활용하면 코드를 자세히 분석해보지 않고도 프로그램의 개략적인 동작을 파악할 수 있습니다. 해시 함수와 같은 비교적 복잡한 알고리즘을 사용하는 함수들은 경험에 의하지 않고서 알고리즘의 종류를 정적 분석으로 판단하기에는 어려움이 있습니다. 하지만, 동적 분석을 통해 프로그램을 분석한다면 어떤 입력 값을 넣고 결과 값이 md5 알고리즘의 결과 값과 같은지 비교하여 해당 함수가 md5함수인지를 쉽게 판단할 수 있습니다.

하지만, 동적 분석을 위해서는 분석하는 프로그램이 대상으로 하는 운영체제, 사양을 가진 컴퓨터를 구하거나 가상머신을 구축해야한다는 환경 구축의 어려움이 있습니다. 또, 프로그램이 분석을 방지하기 위해 *안티 디버깅*(Anti Debugging) 기능을 구현해둔 경우, 디버거를 통해 프로그램을 실행하면 프로그램이 종료되거나 동작을 멈추는 식으로 분석을 방해받을 수 있습니다.
이러한 장치는 단순한 기믹으로, 근본적인 방지책이 되기는 어렵습니다. 대부분의 경우 정적 분석을 통해 어렵지 않게 제거할 수 있습니다.
